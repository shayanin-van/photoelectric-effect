<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Mitr"
    />
    <title>Photoelectric Effect</title>
    <style>
      body {
        font-family: "Mitr", sans-serif;
        color: rgb(114, 114, 114);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
      }
      #myCanvas {
        border: 0px;
        touch-action: none;
        background-color: #ffffff;
        width: 90%;
        max-width: 360px;
        aspect-ratio: 1;
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <div
      style="
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 260px;
        text-align: center;
      "
    >
      <label for="amplitude">พลังงานที่ให้ต่อเวลา</label>
      <input
        type="range"
        id="amplitude"
        name="amplitude"
        min="0.14"
        max="0.3"
        value="0.22"
        step="0.04"
      />
    </div>

    <script>
      // get the canvas element
      const canvas = document.getElementById("myCanvas");
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;

      // get the 2D rendering context
      const ctx = canvas.getContext("2d");

      // sizing
      const phyWidth = 10; // in cm.
      const phyHeight = 10; // in cm.
      let ppcm = canvas.width / phyWidth; // ppcm = pixel per centimeter

      // physics
      const workFunction = 3.8;
      let amplitude = document.getElementById("amplitude").value;
      document.getElementById("amplitude").addEventListener("input", () => {
        amplitude = document.getElementById("amplitude").value;
      });

      // time
      const startTime = Date.now() / 1000;
      let prevTime = startTime;
      let currentTime;
      let deltaTime;

      // coordinate converting function from physical to canvas space
      function xCon(x) {
        return -x + 8.5;
      }
      function yCon(y) {
        return -y + 5;
      }

      // resize event
      window.addEventListener("resize", () => {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        ppcm = canvas.width / phyWidth; // ppcm = pixel per centimeter
      });

      // electron class
      class Electron {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 0.5;

          this.v = 0;
          this.m = 0.01; // electron mass
          this.F = -1; // force acting on electron

          this.isReleased = false;
        }

        createPath() {
          ctx.beginPath();
          ctx.arc(
            xCon(this.x) * ppcm,
            yCon(this.y) * ppcm,
            this.radius * ppcm,
            0,
            2 * Math.PI
          );
        }

        draw() {
          ctx.fillStyle = "#f5b9b0";
          if (this.isHovered) {
            ctx.fillStyle = "#eb978a";
          }
          ctx.strokeStyle = "#d47263";
          ctx.lineWidth = 0.1 * ppcm;
          this.createPath();
          ctx.fill();
          ctx.stroke();

          // text
          ctx.fillStyle = "#d47263";
          ctx.font = 1 * ppcm + "px mitr";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("e", xCon(this.x) * ppcm, yCon(this.y) * ppcm);

          // energy
          if (this.isReleased == false) {
            drawEnergyGap(0, 0, "#8fcf88", 0, this.x);
          }
        }

        update() {
          if (this.isReleased == false) {
            this.v = 6 * amplitude;
          }

          this.x = this.x + this.v * deltaTime;

          if (this.x > workFunction) {
            this.isReleased = true;
          }

          if (this.x > 9.4) {
            this.x = 0;
            this.isReleased = false;
          }

          // draw
          this.draw();
        }
      }

      // light class
      class Light {
        constructor(rotation) {
          this.rotation = rotation;
          this.x = 6;
          this.y = 3.4;

          this.imageScale = 1.4;
          this.imageIsLoad = false;
        }

        drawFlashLight() {
          if (this.imageIsLoad) {
            ctx.save();
            ctx.translate(xCon(this.x) * ppcm, yCon(this.y) * ppcm);
            ctx.rotate(this.rotation);
            ctx.drawImage(
              image,
              0 - ((5 / this.imageScale) * ppcm) / 2,
              0 - ((1.58 / this.imageScale) * ppcm) / 2,
              (5 / this.imageScale) * ppcm,
              (1.58 / this.imageScale) * ppcm
            );
            ctx.restore();
          }
        }

        drawWave() {
          const detail = 100;
          const k = 5;
          const omega = 5;
          const length = Math.sqrt(
            (this.x - electron.x) ** 2 + (this.y - electron.y) ** 2
          );

          ctx.strokeStyle = "#8fcf88";
          ctx.lineWidth = 0.1 * ppcm;
          ctx.beginPath();
          ctx.moveTo(xCon(this.x) * ppcm, yCon(this.y) * ppcm);
          for (let i = 0; i < detail; i++) {
            const x = (length * i) / detail;
            const displacement =
              amplitude * Math.sin(k * x - omega * currentTime);
            const axisX =
              this.x -
              x * Math.cos(this.rotation) -
              displacement * Math.sin(this.rotation);
            const axisY =
              this.y -
              x * Math.sin(this.rotation) +
              displacement * Math.cos(this.rotation);
            ctx.lineTo(xCon(axisX) * ppcm, yCon(axisY) * ppcm);
          }
          ctx.stroke();
        }

        update() {
          if (electron.isReleased) {
            this.rotation = Math.atan2(this.y, this.x - workFunction);
          } else {
            this.rotation = Math.atan2(
              this.y - electron.y,
              this.x - electron.x
            );
            this.drawWave();
          }

          this.drawFlashLight();
        }
      }

      // class instanciation
      const electron = new Electron(0, 0);
      const light = new Light(0);

      // flashlight image
      const image = new Image();
      image.onload = () => {
        light.imageIsLoad = true;
      };
      image.src = "../assets/flashlight.png";

      // animation loop
      function animFrame() {
        requestAnimationFrame(animFrame);
        onEachStep();
      }

      function init() {
        animFrame();
      }

      window.onload = init;

      function onEachStep() {
        // time
        currentTime = Date.now() / 1000;
        elapseTime = currentTime - startTime;
        deltaTime = currentTime - prevTime;
        prevTime = currentTime;
        // set a hard limit for dt in case of stuttering or tab switching
        if (deltaTime > 0.02) {
          deltaTime = 1 / 60;
        }

        // clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // draw functions
        drawMetalSurface();
        drawWorkFunctionBand();
        light.update();
        electron.update();
      }

      function drawMetalSurface() {
        ctx.fillStyle = "#DADBDD";
        ctx.beginPath();
        ctx.rect(xCon(0) * ppcm, yCon(5) * ppcm, 1.5 * ppcm, 10 * ppcm);
        ctx.fill();
      }

      function drawWorkFunctionBand() {
        const gradient = ctx.createLinearGradient(
          xCon(0) * ppcm,
          yCon(5) * ppcm,
          xCon(workFunction) * ppcm,
          yCon(5) * ppcm
        );
        gradient.addColorStop(0, "#aec7e855");
        gradient.addColorStop(1, "#aec7e811");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.rect(
          xCon(workFunction) * ppcm,
          yCon(5) * ppcm,
          workFunction * ppcm,
          10 * ppcm
        );
        ctx.fill();

        drawEnergyGap(0, -3.5, "#aec7e8", 0, workFunction);
      }

      function drawEnergyGap(xStart, yStart, color, angle, length) {
        let arrowSize = 0.5;
        if (length < arrowSize) {
          arrowSize = length;
        }

        // line
        ctx.strokeStyle = color;
        ctx.lineWidth = 0.1 * ppcm;
        ctx.beginPath();
        ctx.moveTo(xCon(xStart) * ppcm, yCon(yStart) * ppcm);
        ctx.lineTo(
          xCon(xStart + (length - arrowSize) * Math.cos(angle)) * ppcm,
          yCon(yStart + (length - arrowSize) * Math.sin(angle)) * ppcm
        );
        ctx.stroke();

        // arrow head
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(
          xCon(xStart + length * Math.cos(angle)) * ppcm,
          yCon(yStart + length * Math.sin(angle)) * ppcm
        );
        ctx.lineTo(
          xCon(
            xStart +
              (length - arrowSize) * Math.cos(angle) +
              0.5 * arrowSize * Math.cos(angle + Math.PI / 2)
          ) * ppcm,
          yCon(
            yStart +
              (length - arrowSize) * Math.sin(angle) +
              0.5 * arrowSize * Math.sin(angle + Math.PI / 2)
          ) * ppcm
        );
        ctx.lineTo(
          xCon(
            xStart +
              (length - arrowSize) * Math.cos(angle) -
              0.5 * arrowSize * Math.cos(angle + Math.PI / 2)
          ) * ppcm,
          yCon(
            yStart +
              (length - arrowSize) * Math.sin(angle) -
              0.5 * arrowSize * Math.sin(angle + Math.PI / 2)
          ) * ppcm
        );
        ctx.fill();

        // line end
        ctx.beginPath();
        ctx.moveTo(
          xCon(
            xStart +
              length * Math.cos(angle) +
              0.5 * arrowSize * Math.cos(angle + Math.PI / 2)
          ) * ppcm,
          yCon(
            yStart +
              length * Math.sin(angle) +
              0.5 * arrowSize * Math.sin(angle + Math.PI / 2)
          ) * ppcm
        );
        ctx.lineTo(
          xCon(
            xStart +
              length * Math.cos(angle) -
              0.5 * arrowSize * Math.cos(angle + Math.PI / 2)
          ) * ppcm,
          yCon(
            yStart +
              length * Math.sin(angle) -
              0.5 * arrowSize * Math.sin(angle + Math.PI / 2)
          ) * ppcm
        );
        ctx.stroke();

        // text
        if (length < 1) {
          return;
        }
        ctx.font = 0.4 * ppcm + "px mitr";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.save();
        ctx.translate(
          xCon(
            xStart +
              0.4 * length * Math.cos(angle) +
              0.5 * Math.cos(angle + Math.PI / 2)
          ) * ppcm,
          yCon(
            yStart +
              0.4 * length * Math.sin(angle) +
              0.5 * Math.sin(angle + Math.PI / 2)
          ) * ppcm
        );
        ctx.rotate(angle);
        ctx.fillText(length.toFixed(1) + " eV", 0, 0);
        ctx.restore();
      }
    </script>
  </body>
</html>
